#include "CompareCommand.h"

#include "util/Random.h"

#include <CLI/CLI.hpp>
#include <command/TestCommand.h>
#include <correlation/Correlation.h>
#include <server/RetaClient.h>
#include <test/TestCase.h>
#include <test/TestInfo.h>

CompareCommand::CompareCommand (CLI::App* app, int& returnValue, FileSystem* fs)
{
    auto compare = app->add_subcommand (
        "compare", "Compare results of two different test runs. The reference can either be a local folder or "
                   "specified using a url to a reta server and a key to identify the plugin");
    compare->add_option ("-r,--reference", parameters.reference,
                         "Path to folder holding the reference output generated by the 'test' stage");
    compare
        ->add_option ("-a,--actual", parameters.actual,
                      "Path to the plugin OR path to folder holding the output of the test-plugin")
        ->required();
    compare->add_option ("-o,--output", parameters.output, "Path to output JSON")->required();
    // compare->add_option ("-s,--strategy", parameters.strategy, "comparison strategy (default: RMSE)");
    compare->add_option ("-d,--delta", parameters.delta, "Allowed delta (default: 0.001f)");
    auto url = compare->add_option ("-u,--url", parameters.url, "Url of reference server");
    auto key = compare->add_option ("-k,--key", parameters.key, "Key of the plugin on the server");
    url->needs (key);

    compare->parse_complete_callback (
        [fs, &returnValue, &parameters = parameters]() { returnValue = execute (parameters, fs); });
}

int CompareCommand::execute (const Parameters& parameters, FileSystem* fs)
{
    if ( parameters.reference.empty() && parameters.url.empty() )
    {
        std::cout << "You must specify either a reference folder or a reference server url" << std::endl;
        return -1;
    }
    size_t numTests;
    juce::String reference = parameters.reference;
    juce::String actual = parameters.actual;
    if ( ! parameters.url.empty() )
    {
        std::cout << "Fetching reference from server: " + parameters.url << std::endl;
        reference = fs->getTempFolder() + juce::Uuid().toString();
        RetaClient::fetchReference (parameters.url, parameters.key, reference, fs);
    }

    if ( fs->isPlugin (actual) )
    {
        std::cout << "Running tests using reference configuration..." << std::endl;
        auto actualOutput = fs->getTempFolder() + juce::Uuid().toString();
        auto referenceConfig = (reference + FileSystem::sep() + "config.json").toStdString();
        TestCommand::execute ({actual.toStdString(), referenceConfig, actualOutput.toStdString()}, fs);
        actual = actualOutput;
    }

    std::cout << "Performing basic tests..." << std::endl;
    TestResult result = performBasicTests (actual, reference, fs, numTests);

    std::cout << "Performing " << numTests << " processing tests..." << std::endl;
    for ( size_t i = 0; i < numTests; ++i )
        result.processingTests.push_back (performProcessingTests (reference, actual, i, parameters.delta, fs));

    return logResults (result, parameters.output, fs);
}

std::vector<TestInfo> CompareCommand::performProcessingTests (const juce::String& reference, const juce::String& actual,
                                                              size_t i, float delta, FileSystem* fs)
{
    std::vector<TestInfo> processing;
    auto infoName = "test" + juce::String (i) + ".json";

    auto referenceInfo = fs->readJson<std::vector<TestCase::Info>> (reference + FileSystem::sep() + infoName);
    auto actualInfo = fs->readJson<std::vector<TestCase::Info>> (actual + FileSystem::sep() + infoName);

    for ( size_t paramIndex = 0; paramIndex < referenceInfo.size(); ++paramIndex )
    {
        auto tests = referenceInfo[paramIndex].compareTo (actualInfo[paramIndex]);
        processing.insert (processing.end(), tests.begin(), tests.end());
    }

    auto wavName = "test" + juce::String (i) + ".wav";
    auto referenceWav = reference + FileSystem::sep() + wavName;
    auto actualWav = actual + FileSystem::sep() + wavName;
    float diff = Correlation::rmse (fs, referenceWav, actualWav);
    processing.push_back ({"RMSE diff", std::to_string (delta), std::to_string (diff), diff <= delta});

    for ( auto& test : processing )
        test.configIndex = i;

    return processing;
}

TestResult CompareCommand::performBasicTests (const juce::String& reference, const juce::String& actual, FileSystem* fs,
                                              size_t& numTests)
{
    TestResult result;
    auto referenceInfo = fs->readJson<Plugin::Info> (reference + FileSystem::sep() + "info.json");
    auto actualInfo = fs->readJson<Plugin::Info> (actual + FileSystem::sep() + "info.json");
    auto referenceConfig = fs->readJson<TestConfigurations> (reference + FileSystem::sep() + "config.json");
    auto actualConfig = fs->readJson<TestConfigurations> (actual + FileSystem::sep() + "config.json");

    result.basicTests = referenceInfo.compareTo (actualInfo);
    result.busLayoutTests = BusLayout::compare (referenceInfo.layouts, actualInfo.layouts);
    result.parameterTests = Plugin::ParameterInfo::compare (referenceInfo.parameters, actualInfo.parameters);
    result.configTests = TestConfiguration::compare (referenceConfig, actualConfig);

    numTests = referenceConfig.size();

    return result;
}

int CompareCommand::logResults (const TestResult& result, const std::string& outputFile, FileSystem* fs)
{
    std::cout << "Collecting results..." << std::endl;

    size_t numFailed = 0;
    numFailed += log (result.basicTests);
    numFailed += log (result.busLayoutTests);
    numFailed += log (result.parameterTests);
    numFailed += log (result.configTests);
    numFailed += log (result.processingTests);

    std::cout << "=================" << std::endl;
    std::cout << "Num Failed: " << numFailed << std::endl;
    std::cout << "=================" << std::endl;

    fs->writeJson (outputFile, result, true);
    return static_cast<int> (numFailed);
}
size_t CompareCommand::log (const std::vector<TestInfos>& infos)
{
    size_t numFailed = 0;
    for ( const auto& testInfos : infos )
        numFailed += log (testInfos);
    return numFailed;
}
size_t CompareCommand::log (const std::vector<TestInfo>& infos)
{
    size_t numFailed = 0;
    for ( const auto& info : infos )
    {
        if ( ! info.passed )
        {
            numFailed++;
            std::cout << "- Failed: " << info.name << std::endl;
            std::cout << "  Expected: " << info.expected << ", Actual: " << info.actual << std::endl;
            if ( info.configIndex != -1 )
                std::cout << "  Failure at test config #" << info.configIndex << std::endl;
        }
    }
    return numFailed;
}
